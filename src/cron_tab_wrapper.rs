use clap::builder::Str;
use cron_tab::*;
use chrono::Utc;
use crate::{Job, JobParams};
use std::process::Command;
use std::fs;
use std::path::PathBuf;
use std::error::Error;
use crate::user_jobs::*;

//let utc_tz = Utc;


pub fn create_job(job: Job, cron: &mut Cron<Utc>) {
    cron.add_fn(&job.timing.full_timing(), move || execute_job(&job.name, &job.params).unwrap()).unwrap();
}

//TODO Add global log to capture errors not generated by user commands
//TODO Find a way to redirect errors
//TODO Append to output (optional?)
fn execute_job(name: &String, params: &JobParams) -> core::result::Result<(), Box<dyn Error>> {
    info!("Running: {}", name);
    let output = Command::new("sh")
                                .arg("-c")
                                .arg(&params.command)
                                .output()
                                .map_err(|e| {
                                    error!("Error when running command: {:?}", e);
                                    e
                                })?;
    fs::write(&params.log_location, output.stdout).map_err(|e| {
        error!("Could not write to log location: {:?}", e);
        e
    })?;

    if output.stderr.len() > 0 {
        info!("The job \"{}\" encountered and error", name);
        let mut error_path = PathBuf::from(&params.log_location);
        error_path.pop();
        error_path.push("error.log");
        info!("stderr written to: {}", error_path.display());
        fs::write(error_path, output.stderr).map_err(|e| {
            error!("Could not write to error location: {:?}", e);
            e
        })?;
    }
    
    Ok(())
}

pub fn init_cron(job_file: &PathBuf) -> Cron<Utc> {
    debug!("started reading from file");
    //read from file
    let input = fs::read_to_string(&job_file).unwrap();
    let new_jobs: JobList = serde_yaml_ng::from_str(&input).unwrap();
    debug!("Job count: {}", new_jobs.jobs.len());
    debug!("creating crontabs");
    let mut cron = cron_tab::Cron::new(Utc);
    for j in new_jobs.jobs {
        create_job(j, &mut cron);
    }

    cron.start();
    return cron;
}

pub fn stop_cron(c: &Cron<Utc>) {
    c.stop();
}